#!/usr/bin/env python3
"""
Line Drawing to G-Code Converter
Converts line drawings (PNG, JPG, SVG) into G-Code for CNC machines
"""

import sys
import os
import argparse
from pathlib import Path
import numpy as np

try:
    import cv2
    HAS_CV2 = True
except ImportError:
    HAS_CV2 = False
    print("Warning: OpenCV not installed. Image file support will be limited.")
    print("Install with: pip install opencv-python")

try:
    from xml.etree import ElementTree as ET
    import re
    HAS_SVG = True
except ImportError:
    HAS_SVG = False

try:
    import ezdxf
    HAS_DXF = True
except ImportError:
    HAS_DXF = False
    print("Warning: ezdxf not installed. DXF export will not be available.")
    print("Install with: pip install ezdxf")


class GCodeGenerator:
    """Generates G-Code from paths"""
    
    def __init__(self, params):
        self.params = params
        self.gcode = []
        self.current_z = params['safe_height']
        
    def generate_header(self):
        """Generate G-Code header"""
        p = self.params
        
        header = [
            f"; Generated by Line to G-Code Converter",
            f"; File: {p['filename']}",
            f"; Tool diameter: {p['tool_diameter']} {p['units']}",
            f"; Cut depth: {p['cut_depth']} {p['units']}",
            f"; Feed rate: {p['feed_rate']} {p['units']}/min",
            "",
            "G21" if p['units'] == 'mm' else "G20",  # Set units
            "G90",  # Absolute positioning
            "G17",  # XY plane
            f"G0 Z{p['safe_height']}",  # Move to safe height
            f"M3 S{p['spindle_speed']}" if p['spindle_speed'] > 0 else "; Spindle control disabled",
            "G4 P2",  # Dwell 2 seconds
            ""
        ]
        
        self.gcode.extend(header)
        
    def generate_footer(self):
        """Generate G-Code footer"""
        p = self.params
        
        footer = [
            "",
            f"; Total paths: {len(self.params.get('paths', []))}",
            f"G0 Z{p['safe_height']}",  # Retract to safe height
            "G0 X0 Y0",  # Return to origin
            "M5" if p['spindle_speed'] > 0 else "; Spindle already off",  # Stop spindle
            "M2",  # End program
            ""
        ]
        
        self.gcode.extend(footer)
        
    def move_to(self, x, y, rapid=True):
        """Generate a move command"""
        command = "G0" if rapid else "G1"
        self.gcode.append(f"{command} X{x:.4f} Y{y:.4f}")
        
    def plunge(self):
        """Plunge to cutting depth"""
        p = self.params
        self.gcode.append(f"G1 Z{-p['cut_depth']:.4f} F{p['plunge_rate']}")
        self.current_z = -p['cut_depth']
        
    def retract(self):
        """Retract to safe height"""
        p = self.params
        self.gcode.append(f"G0 Z{p['safe_height']:.4f}")
        self.current_z = p['safe_height']
        
    def cut_path(self, points):
        """Cut along a path of points"""
        if len(points) < 2:
            return
            
        p = self.params
        
        # Move to start point at safe height
        self.move_to(points[0][0], points[0][1], rapid=True)
        
        # Plunge
        self.plunge()
        
        # Cut along path
        for point in points[1:]:
            self.gcode.append(f"G1 X{point[0]:.4f} Y{point[1]:.4f} F{p['feed_rate']}")
        
        # Retract
        self.retract()
        self.gcode.append("")  # Blank line for readability
        
    def generate_from_paths(self, paths):
        """Generate G-Code from a list of paths"""
        self.params['paths'] = paths
        self.generate_header()
        
        for i, path in enumerate(paths):
            self.gcode.append(f"; Path {i+1}/{len(paths)}")
            self.cut_path(path)
        
        self.generate_footer()
        
    def save(self, output_file):
        """Save G-Code to file"""
        with open(output_file, 'w') as f:
            f.write('\n'.join(self.gcode))
        print(f"G-Code saved to: {output_file}")


class SVGExporter:
    """Export paths to SVG format"""
    
    @staticmethod
    def export(paths, width, height, output_file, units='mm'):
        """
        Export paths to SVG file
        
        Args:
            paths: List of paths (each path is list of (x, y) tuples)
            width: Canvas width
            height: Canvas height
            output_file: Output SVG filename
            units: Units for dimensions (mm or inch)
        """
        # Create SVG root element
        svg = ET.Element('svg', {
            'xmlns': 'http://www.w3.org/2000/svg',
            'width': f'{width}{units}',
            'height': f'{height}{units}',
            'viewBox': f'0 0 {width} {height}'
        })
        
        # Add comment
        comment = ET.Comment(f' Generated by Line to G-Code Converter - {len(paths)} paths ')
        svg.append(comment)
        
        # Create a group for all paths
        group = ET.SubElement(svg, 'g', {
            'fill': 'none',
            'stroke': 'black',
            'stroke-width': '0.5'
        })
        
        # Add each path
        for i, path in enumerate(paths):
            if len(path) < 2:
                continue
            
            # Build path data string
            path_data = f"M {path[0][0]:.4f} {path[0][1]:.4f}"
            for point in path[1:]:
                path_data += f" L {point[0]:.4f} {point[1]:.4f}"
            
            # Create path element
            ET.SubElement(group, 'path', {
                'd': path_data,
                'id': f'path{i+1}'
            })
        
        # Write to file
        tree = ET.ElementTree(svg)
        ET.indent(tree, space='  ')
        tree.write(output_file, encoding='utf-8', xml_declaration=True)
        print(f"SVG saved to: {output_file}")


class DXFExporter:
    """Export paths to DXF format"""
    
    @staticmethod
    def export(paths, output_file, units='mm'):
        """
        Export paths to DXF file
        
        Args:
            paths: List of paths (each path is list of (x, y) tuples)
            output_file: Output DXF filename
            units: Units for dimensions (mm or inch)
        """
        if not HAS_DXF:
            print("Error: ezdxf not installed. Cannot export DXF.")
            print("Install with: pip install ezdxf")
            return False
        
        # Create new DXF document
        doc = ezdxf.new('R2010')
        
        # Set units
        if units == 'mm':
            doc.units = ezdxf.units.MM
        else:
            doc.units = ezdxf.units.IN
        
        # Get modelspace
        msp = doc.modelspace()
        
        # Add each path as a polyline
        for i, path in enumerate(paths):
            if len(path) < 2:
                continue
            
            # Create polyline
            polyline = msp.add_lwpolyline(
                points=path,
                dxfattribs={'layer': 'PATHS'}
            )
        
        # Save DXF file
        doc.saveas(output_file)
        print(f"DXF saved to: {output_file}")
        return True


class ImageProcessor:
    """Process raster images to extract paths"""
    
    @staticmethod
    def skeletonize(binary_image):
        """
        Perform morphological skeletonization to find centerline of thick lines.
        Uses Zhang-Suen thinning algorithm via OpenCV.
        """
        # Use morphological thinning to get skeleton
        skeleton = cv2.ximgproc.thinning(binary_image, thinningType=cv2.ximgproc.THINNING_ZHANGSUEN)
        return skeleton
    
    @staticmethod
    def smooth_path(path, smoothing_factor=5):
        """
        Smooth a path using moving average filter.
        
        Args:
            path: List of (x, y) tuples
            smoothing_factor: Window size for smoothing (higher = smoother)
        
        Returns:
            Smoothed path as list of (x, y) tuples
        """
        if len(path) < smoothing_factor:
            return path
        
        # Convert to numpy array for easier manipulation
        path_array = np.array(path)
        
        # Apply moving average
        smoothed = np.zeros_like(path_array, dtype=float)
        for i in range(len(path_array)):
            start = max(0, i - smoothing_factor // 2)
            end = min(len(path_array), i + smoothing_factor // 2 + 1)
            smoothed[i] = np.mean(path_array[start:end], axis=0)
        
        # Convert back to list of tuples
        return [(float(x), float(y)) for x, y in smoothed]
    
    @staticmethod
    def fit_spline_path(path, num_points=None, smoothness=0.5):
        """
        Fit a smooth spline through path points.
        
        Args:
            path: List of (x, y) tuples
            num_points: Number of points in output (default: same as input)
            smoothness: Smoothing parameter (0-1, higher = smoother)
        
        Returns:
            Smoothed path with spline interpolation
        """
        if len(path) < 4:
            return path
        
        from scipy import interpolate
        
        path_array = np.array(path)
        x = path_array[:, 0]
        y = path_array[:, 1]
        
        # Calculate cumulative distance along path for parameterization
        distances = np.sqrt(np.sum(np.diff(path_array, axis=0)**2, axis=1))
        distances = np.concatenate(([0], np.cumsum(distances)))
        
        # Normalize distances to 0-1 range
        if distances[-1] > 0:
            t = distances / distances[-1]
        else:
            t = np.linspace(0, 1, len(path))
        
        # Fit spline with smoothing
        k = min(3, len(path) - 1)  # Spline degree (cubic if possible)
        s_factor = smoothness * len(path)  # Smoothing factor
        
        try:
            tck_x, _ = interpolate.splrep(t, x, s=s_factor, k=k)
            tck_y, _ = interpolate.splrep(t, y, s=s_factor, k=k)
            
            # Generate smooth path
            if num_points is None:
                num_points = len(path)
            
            t_new = np.linspace(0, 1, num_points)
            x_new = interpolate.splev(t_new, tck_x)
            y_new = interpolate.splev(t_new, tck_y)
            
            return [(float(x), float(y)) for x, y in zip(x_new, y_new)]
        except:
            # If spline fitting fails, fall back to moving average
            return ImageProcessor.smooth_path(path, smoothing_factor=5)
    
    @staticmethod
    def order_skeleton_points(skeleton):
        """
        Extract ordered paths from skeletonized image.
        Handles branches and multiple disconnected lines.
        """
        # Find all skeleton pixels
        skeleton_points = np.column_stack(np.where(skeleton > 0))
        
        if len(skeleton_points) == 0:
            return []
        
        # Find connected components
        num_labels, labels = cv2.connectedComponents(skeleton)
        
        paths = []
        for label in range(1, num_labels):  # Skip background (0)
            # Get points for this component
            component_mask = (labels == label).astype(np.uint8) * 255
            
            # Find endpoints and junctions
            # Endpoints have exactly 1 neighbor, junctions have 3+
            kernel = np.ones((3, 3), np.uint8)
            neighbors = cv2.filter2D(component_mask, -1, kernel) / 255
            neighbors = neighbors * (component_mask > 0)
            
            endpoints = np.where(neighbors == 2)  # Endpoint has 1 neighbor + itself = 2
            
            if len(endpoints[0]) == 0:
                # Closed loop - start anywhere
                points = np.column_stack(np.where(component_mask > 0))
                if len(points) > 0:
                    start = points[0]
                    path = ImageProcessor.trace_skeleton_path(component_mask, start)
                    if len(path) >= 2:
                        paths.append(path)
            else:
                # Start from each endpoint and trace
                for i in range(len(endpoints[0])):
                    start = (endpoints[0][i], endpoints[1][i])
                    path = ImageProcessor.trace_skeleton_path(component_mask, start)
                    if len(path) >= 2:
                        paths.append(path)
        
        return paths
    
    @staticmethod
    def trace_skeleton_path(skeleton, start):
        """
        Trace a path along skeleton starting from a point.
        Uses 8-connectivity to follow the skeleton.
        """
        visited = np.zeros_like(skeleton, dtype=bool)
        path = []
        
        current = start
        path.append((current[1], current[0]))  # Note: (x, y) format, not (row, col)
        visited[current[0], current[1]] = True
        
        # 8-connectivity offsets
        offsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]
        
        while True:
            # Find next unvisited neighbor
            found = False
            for dy, dx in offsets:
                ny, nx = current[0] + dy, current[1] + dx
                
                if (0 <= ny < skeleton.shape[0] and 
                    0 <= nx < skeleton.shape[1] and
                    skeleton[ny, nx] > 0 and 
                    not visited[ny, nx]):
                    
                    current = (ny, nx)
                    path.append((nx, ny))  # (x, y) format
                    visited[ny, nx] = True
                    found = True
                    break
            
            if not found:
                break
        
        return path
    
    @staticmethod
    def load_and_process(image_path, threshold=127, simplify_epsilon=1.0, 
                        use_skeleton=False, smooth_level=5, use_spline=False):
        """
        Load image and extract contours or skeleton paths.
        
        Args:
            image_path: Path to image file
            threshold: Threshold for binarization (0-255)
            simplify_epsilon: Epsilon for contour simplification
            use_skeleton: If True, use skeletonization for thick/variable width lines
            smooth_level: Smoothing factor (higher = smoother)
            use_spline: If True, use spline fitting for very smooth curves
        
        Returns:
            paths: List of paths (each path is list of (x, y) tuples)
            width: Image width
            height: Image height
        """
        if not HAS_CV2:
            raise ImportError("OpenCV required for image processing. Install: pip install opencv-python")
        
        # Load image
        img = cv2.imread(str(image_path))
        if img is None:
            raise ValueError(f"Could not load image: {image_path}")
        
        # Convert to grayscale
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        
        # Threshold to binary
        _, binary = cv2.threshold(gray, threshold, 255, cv2.THRESH_BINARY_INV)
        
        paths = []
        
        if use_skeleton:
            # Use skeletonization for thick/variable width lines
            print("Skeletonizing image to find centerlines...")
            
            try:
                skeleton = ImageProcessor.skeletonize(binary)
            except AttributeError:
                # If ximgproc not available, use alternative method
                print("Note: Using alternative skeletonization method")
                skeleton = ImageProcessor.skeletonize_alternative(binary)
            
            # Extract ordered paths from skeleton
            skeleton_paths = ImageProcessor.order_skeleton_points(skeleton)
            
            # Smooth each path
            for path in skeleton_paths:
                if len(path) >= 2:
                    if use_spline and len(path) >= 4:
                        # Use spline fitting for smoother curves
                        smoothed = ImageProcessor.fit_spline_path(path, smoothness=0.5)
                    else:
                        # Use moving average smoothing
                        smoothed = ImageProcessor.smooth_path(path, smooth_level)
                    
                    # Simplify to reduce point count
                    if simplify_epsilon > 0:
                        # Convert to numpy array for simplification
                        path_array = np.array(smoothed, dtype=np.float32)
                        path_array = path_array.reshape((-1, 1, 2))
                        simplified = cv2.approxPolyDP(path_array, simplify_epsilon, False)
                        smoothed = [(float(point[0][0]), float(point[0][1])) for point in simplified]
                    
                    if len(smoothed) >= 2:
                        paths.append(smoothed)
        
        else:
            # Use contour detection for clean line drawings
            # Use RETR_EXTERNAL to get only outermost contours (avoids double lines)
            contours, _ = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
            
            # Convert contours to paths and simplify
            for contour in contours:
                # Filter out very small contours (noise)
                if len(contour) < 3:
                    continue
                
                # Simplify contour
                epsilon = simplify_epsilon
                simplified = cv2.approxPolyDP(contour, epsilon, False)
                
                # Convert to list of points
                path = [(float(point[0][0]), float(point[0][1])) for point in simplified]
                
                if len(path) >= 2:  # Only keep paths with at least 2 points
                    paths.append(path)
        
        # Get image dimensions for scaling
        height, width = gray.shape
        
        return paths, width, height
    
    @staticmethod
    def skeletonize_alternative(binary_image):
        """
        Alternative skeletonization using morphological operations.
        Works when ximgproc is not available.
        """
        # Create a copy
        skeleton = np.zeros(binary_image.shape, dtype=np.uint8)
        img = binary_image.copy()
        
        # Get structuring element
        element = cv2.getStructuringElement(cv2.MORPH_CROSS, (3, 3))
        
        while True:
            # Erode
            eroded = cv2.erode(img, element)
            # Dilate the eroded image
            temp = cv2.dilate(eroded, element)
            # Subtract
            temp = cv2.subtract(img, temp)
            # Add to skeleton
            skeleton = cv2.bitwise_or(skeleton, temp)
            # Update image
            img = eroded.copy()
            
            # Stop when fully eroded
            if cv2.countNonZero(img) == 0:
                break
        
        return skeleton


class SVGProcessor:
    """Process SVG files to extract paths"""
    
    @staticmethod
    def parse_path_data(path_string):
        """Parse SVG path data into points"""
        points = []
        
        # Simple parser for basic SVG commands (M, L, H, V, Z)
        commands = re.findall(r'[MLHVZmlhvz][^MLHVZmlhvz]*', path_string)
        
        current_pos = [0.0, 0.0]
        
        for cmd in commands:
            cmd_type = cmd[0]
            coords = re.findall(r'-?\d+\.?\d*', cmd[1:])
            coords = [float(c) for c in coords]
            
            if cmd_type in ['M', 'm']:  # Move to
                if cmd_type == 'M':  # Absolute
                    current_pos = [coords[0], coords[1]]
                else:  # Relative
                    current_pos[0] += coords[0]
                    current_pos[1] += coords[1]
                points.append(tuple(current_pos))
                
            elif cmd_type in ['L', 'l']:  # Line to
                for i in range(0, len(coords), 2):
                    if cmd_type == 'L':  # Absolute
                        current_pos = [coords[i], coords[i+1]]
                    else:  # Relative
                        current_pos[0] += coords[i]
                        current_pos[1] += coords[i+1]
                    points.append(tuple(current_pos))
            
            elif cmd_type in ['H', 'h']:  # Horizontal line
                for coord in coords:
                    if cmd_type == 'H':
                        current_pos[0] = coord
                    else:
                        current_pos[0] += coord
                    points.append(tuple(current_pos))
            
            elif cmd_type in ['V', 'v']:  # Vertical line
                for coord in coords:
                    if cmd_type == 'V':
                        current_pos[1] = coord
                    else:
                        current_pos[1] += coord
                    points.append(tuple(current_pos))
            
            elif cmd_type in ['Z', 'z']:  # Close path
                if points:
                    points.append(points[0])
        
        return points
    
    @staticmethod
    def load_and_process(svg_path):
        """Load SVG and extract paths"""
        tree = ET.parse(svg_path)
        root = tree.getroot()
        
        # Handle namespace
        ns = {'svg': 'http://www.w3.org/2000/svg'}
        
        paths = []
        
        # Find all path elements
        for path_elem in root.findall('.//svg:path', ns) + root.findall('.//path'):
            d = path_elem.get('d')
            if d:
                points = SVGProcessor.parse_path_data(d)
                if len(points) >= 2:
                    paths.append(points)
        
        # Get SVG dimensions
        width = float(root.get('width', 100))
        height = float(root.get('height', 100))
        
        return paths, width, height


def remove_duplicate_paths(paths, distance_threshold=5.0):
    """
    Remove duplicate or very close parallel paths.
    This fixes the "double line" issue when both edges of a thick line are detected.
    
    Args:
        paths: List of paths
        distance_threshold: Maximum distance between paths to consider them duplicates
    
    Returns:
        Filtered list of paths with duplicates removed
    """
    if len(paths) <= 1:
        return paths
    
    # Calculate representative points for each path (centroid)
    path_centroids = []
    for path in paths:
        if len(path) > 0:
            xs = [p[0] for p in path]
            ys = [p[1] for p in path]
            centroid = (np.mean(xs), np.mean(ys))
            path_centroids.append(centroid)
        else:
            path_centroids.append(None)
    
    # Mark paths to keep
    keep = [True] * len(paths)
    
    for i in range(len(paths)):
        if not keep[i] or path_centroids[i] is None:
            continue
            
        for j in range(i + 1, len(paths)):
            if not keep[j] or path_centroids[j] is None:
                continue
            
            # Check if centroids are very close
            dx = path_centroids[i][0] - path_centroids[j][0]
            dy = path_centroids[i][1] - path_centroids[j][1]
            dist = np.sqrt(dx*dx + dy*dy)
            
            # If paths are very close, keep the longer one
            if dist < distance_threshold:
                if len(paths[i]) >= len(paths[j]):
                    keep[j] = False
                else:
                    keep[i] = False
                    break
    
    # Return filtered paths
    filtered = [paths[i] for i in range(len(paths)) if keep[i]]
    return filtered


def merge_close_endpoints(paths, merge_threshold=10.0):
    """
    Merge paths that have endpoints very close together.
    This helps create continuous paths from broken line segments.
    """
    if len(paths) <= 1:
        return paths
    
    merged = True
    result_paths = list(paths)
    
    while merged and len(result_paths) > 1:
        merged = False
        
        for i in range(len(result_paths)):
            if i >= len(result_paths):
                break
                
            path1 = result_paths[i]
            if len(path1) < 2:
                continue
            
            start1 = path1[0]
            end1 = path1[-1]
            
            for j in range(i + 1, len(result_paths)):
                if j >= len(result_paths):
                    break
                    
                path2 = result_paths[j]
                if len(path2) < 2:
                    continue
                
                start2 = path2[0]
                end2 = path2[-1]
                
                # Check all possible connections
                connections = [
                    ('end1_start2', end1, start2, lambda: path1 + path2),
                    ('end1_end2', end1, end2, lambda: path1 + path2[::-1]),
                    ('start1_start2', start1, start2, lambda: path1[::-1] + path2),
                    ('start1_end2', start1, end2, lambda: path1[::-1] + path2[::-1]),
                ]
                
                for conn_type, pt1, pt2, merge_func in connections:
                    dist = np.sqrt((pt1[0] - pt2[0])**2 + (pt1[1] - pt2[1])**2)
                    
                    if dist < merge_threshold:
                        # Merge the paths
                        result_paths[i] = merge_func()
                        result_paths.pop(j)
                        merged = True
                        break
                
                if merged:
                    break
            
            if merged:
                break
    
    return result_paths


def scale_paths(paths, src_width, src_height, target_width, target_height, flip_y=True):
    """Scale paths from source dimensions to target dimensions"""
    scale_x = target_width / src_width
    scale_y = target_height / src_height
    
    scaled_paths = []
    for path in paths:
        scaled_path = []
        for x, y in path:
            new_x = x * scale_x
            new_y = (src_height - y) * scale_y if flip_y else y * scale_y
            scaled_path.append((new_x, new_y))
        scaled_paths.append(scaled_path)
    
    return scaled_paths


def get_user_inputs():
    """Get machining parameters from user"""
    print("\n=== CNC Machining Parameters ===\n")
    
    # Units
    units = input("Units (mm/inch) [mm]: ").strip().lower() or 'mm'
    if units not in ['mm', 'inch', 'in']:
        units = 'mm'
    if units == 'in':
        units = 'inch'
    
    # Material dimensions
    print(f"\nMaterial dimensions ({units}):")
    material_width = float(input(f"  Width [{100 if units == 'mm' else 4}]: ") or (100 if units == 'mm' else 4))
    material_height = float(input(f"  Height [{100 if units == 'mm' else 4}]: ") or (100 if units == 'mm' else 4))
    
    # Tool parameters
    print(f"\nTool parameters ({units}):")
    tool_diameter = float(input(f"  Tool diameter [{3.175 if units == 'mm' else 0.125}]: ") or (3.175 if units == 'mm' else 0.125))
    cut_depth = float(input(f"  Cut depth [{1 if units == 'mm' else 0.04}]: ") or (1 if units == 'mm' else 0.04))
    
    # Speeds and feeds
    print(f"\nSpeeds and feeds ({units}/min):")
    feed_rate = float(input(f"  Feed rate [{500 if units == 'mm' else 30}]: ") or (500 if units == 'mm' else 30))
    plunge_rate = float(input(f"  Plunge rate [{200 if units == 'mm' else 10}]: ") or (200 if units == 'mm' else 10))
    safe_height = float(input(f"  Safe height [{5 if units == 'mm' else 0.2}]: ") or (5 if units == 'mm' else 0.2))
    
    # Spindle
    spindle_speed = input("  Spindle speed (RPM) [0 for manual]: ").strip()
    spindle_speed = int(spindle_speed) if spindle_speed else 0
    
    params = {
        'units': units,
        'material_width': material_width,
        'material_height': material_height,
        'tool_diameter': tool_diameter,
        'cut_depth': cut_depth,
        'feed_rate': feed_rate,
        'plunge_rate': plunge_rate,
        'safe_height': safe_height,
        'spindle_speed': spindle_speed
    }
    
    return params


def main():
    parser = argparse.ArgumentParser(description='Convert line drawings to G-Code, DXF, or SVG')
    parser.add_argument('input_file', help='Input file (PNG, JPG, or SVG)')
    parser.add_argument('-o', '--output', help='Output file base name (extensions added automatically)')
    parser.add_argument('--format', choices=['nc', 'gcode', 'dxf', 'svg', 'all'], 
                       default='nc', 
                       help='Output format: nc/gcode (G-Code), dxf (DXF), svg (SVG), or all (default: nc)')
    parser.add_argument('-t', '--threshold', type=int, default=127, 
                       help='Threshold for image binarization (0-255, default: 127)')
    parser.add_argument('-s', '--simplify', type=float, default=1.0,
                       help='Path simplification epsilon (default: 1.0)')
    parser.add_argument('--skeleton', action='store_true',
                       help='Use skeletonization for thick/variable width pencil lines')
    parser.add_argument('--smooth', type=int, default=5,
                       help='Smoothing level for skeleton paths (default: 5)')
    parser.add_argument('--spline', action='store_true',
                       help='Use spline fitting for very smooth curves (requires scipy)')
    parser.add_argument('--params', help='JSON file with machining parameters')
    parser.add_argument('--skip-gcode-params', action='store_true',
                       help='Skip machining parameter input (only for DXF/SVG output)')
    
    args = parser.parse_args()
    
    # Check if input file exists
    input_path = Path(args.input_file)
    if not input_path.exists():
        print(f"Error: File not found: {input_path}")
        sys.exit(1)
    
    # Determine file type
    file_ext = input_path.suffix.lower()
    
    print(f"Loading: {input_path}")
    
    # Check if spline requested but scipy not available
    if args.spline:
        try:
            import scipy
            print("Using spline fitting for smooth curves")
        except ImportError:
            print("Warning: scipy not installed. Falling back to moving average smoothing.")
            print("Install scipy with: pip install scipy")
            args.spline = False
    
    # Load and process file
    try:
        if file_ext in ['.png', '.jpg', '.jpeg', '.bmp', '.tiff']:
            if args.skeleton:
                print(f"Processing with skeletonization (smooth level: {args.smooth})...")
            
            paths, src_width, src_height = ImageProcessor.load_and_process(
                input_path, 
                threshold=args.threshold,
                simplify_epsilon=args.simplify,
                use_skeleton=args.skeleton,
                smooth_level=args.smooth,
                use_spline=args.spline
            )
            
            processing_method = "skeleton" if args.skeleton else "contour"
            print(f"Extracted {len(paths)} paths from image using {processing_method} method ({src_width}x{src_height})")
            
        elif file_ext == '.svg':
            paths, src_width, src_height = SVGProcessor.load_and_process(input_path)
            print(f"Extracted {len(paths)} paths from SVG ({src_width}x{src_height})")
            
        else:
            print(f"Error: Unsupported file type: {file_ext}")
            print("Supported: .png, .jpg, .jpeg, .svg")
            sys.exit(1)
    
    except Exception as e:
        print(f"Error processing file: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
    
    if not paths:
        print("Error: No paths found in file")
        sys.exit(1)
    
    # Remove duplicate/parallel paths (fixes double-line issue)
    if args.skeleton or len(paths) > 5:
        print(f"Found {len(paths)} initial paths")
        paths = remove_duplicate_paths(paths, distance_threshold=10.0)
        print(f"After removing duplicates: {len(paths)} paths")
        
        # Merge paths with close endpoints
        paths = merge_close_endpoints(paths, merge_threshold=15.0)
        print(f"After merging close paths: {len(paths)} paths")
    
    if not paths:
        print("Error: No paths remaining after filtering")
        sys.exit(1)
    
    # Determine output format(s)
    output_formats = []
    if args.format == 'all':
        output_formats = ['nc', 'dxf', 'svg']
    else:
        output_formats = [args.format if args.format != 'gcode' else 'nc']
    
    # Check if G-Code output is requested
    needs_gcode_params = 'nc' in output_formats
    
    # Get machining parameters if generating G-Code
    if needs_gcode_params and not args.skip_gcode_params:
        params = get_user_inputs()
        params['filename'] = input_path.name
        
        # Scale paths to material size
        print(f"\nScaling paths to {params['material_width']}x{params['material_height']} {params['units']}")
        scaled_paths = scale_paths(
            paths, 
            src_width, 
            src_height, 
            params['material_width'], 
            params['material_height'],
            flip_y=True
        )
    else:
        # For DXF/SVG only, use original dimensions or prompt for scaling
        if not args.skip_gcode_params:
            print("\n=== Output Dimensions ===")
            units = input("Units (mm/inch) [mm]: ").strip().lower() or 'mm'
            if units not in ['mm', 'inch', 'in']:
                units = 'mm'
            if units == 'in':
                units = 'inch'
            
            output_width = input(f"Output width ({units}) [use original]: ").strip()
            output_height = input(f"Output height ({units}) [use original]: ").strip()
            
            if output_width and output_height:
                output_width = float(output_width)
                output_height = float(output_height)
                print(f"Scaling to {output_width}x{output_height} {units}")
                scaled_paths = scale_paths(paths, src_width, src_height, 
                                         output_width, output_height, flip_y=True)
            else:
                print("Using original dimensions")
                scaled_paths = paths
                output_width = src_width
                output_height = src_height
                units = 'px'
        else:
            scaled_paths = paths
            output_width = src_width
            output_height = src_height
            units = 'px'
            params = None
    
    # Determine output base filename
    if args.output:
        output_base = Path(args.output).stem
        output_dir = Path(args.output).parent if Path(args.output).parent.name else Path('.')
    else:
        output_base = input_path.stem
        output_dir = Path('.')
    
    # Generate output files
    print("\n=== Generating Output Files ===")
    output_files = []
    
    for fmt in output_formats:
        if fmt == 'nc':
            # Generate G-Code
            output_file = output_dir / f"{output_base}.nc"
            print(f"\nGenerating G-Code...")
            generator = GCodeGenerator(params)
            generator.generate_from_paths(scaled_paths)
            generator.save(output_file)
            output_files.append(output_file)
            
        elif fmt == 'dxf':
            # Generate DXF
            output_file = output_dir / f"{output_base}.dxf"
            print(f"\nGenerating DXF...")
            if DXFExporter.export(scaled_paths, output_file, units):
                output_files.append(output_file)
            
        elif fmt == 'svg':
            # Generate SVG
            output_file = output_dir / f"{output_base}.svg"
            print(f"\nGenerating SVG...")
            if needs_gcode_params:
                svg_width = params['material_width']
                svg_height = params['material_height']
                svg_units = params['units']
            else:
                svg_width = output_width
                svg_height = output_height
                svg_units = units
            SVGExporter.export(scaled_paths, svg_width, svg_height, output_file, svg_units)
            output_files.append(output_file)
    
    # Print summary
    print("\n=== Summary ===")
    print(f"Input file: {input_path}")
    print(f"Processing: {'Skeleton + smoothing' if args.skeleton else 'Contour detection'}")
    print(f"Paths generated: {len(scaled_paths)}")
    print(f"Total points: {sum(len(p) for p in scaled_paths)}")
    print(f"\nOutput files created:")
    for output_file in output_files:
        print(f"  - {output_file}")
    
    if needs_gcode_params and params:
        print(f"\nG-Code Details:")
        print(f"  Material: {params['material_width']} x {params['material_height']} {params['units']}")
        print(f"  Cut depth: {params['cut_depth']} {params['units']}")
        print(f"  Feed rate: {params['feed_rate']} {params['units']}/min")
    
    print("\nDone!")


if __name__ == '__main__':
    main()
